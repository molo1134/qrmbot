#!/usr/bin/perl -w

# Find current POTA activity
# Borrowing some code from "spots" program

# 2-clause BSD license.
# Copyright (c) 2018,2022 molo1134@github. All rights reserved.

use strict;
use DateTime::Format::Strptime;
use JSON qw( decode_json );
use v5.10;

use POSIX qw(strftime);

use File::Basename;
use Cwd 'realpath';
use lib dirname(realpath(__FILE__));
use Location;
use Util;

my $username = $ENV{'USER'} || $ENV{'USERNAME'} || getpwuid($<);

# configuration
our $exitnonzeroonerror = 1;
$exitnonzeroonerror = 0 if $username eq getEggdropUID();

my $defaultSpots = 20;
my $defaultSpotsForEggdrop = 3;

my $limit;
if ($username eq getEggdropUID()) {
  $limit = $defaultSpotsForEggdrop;
} else {
  $limit = $defaultSpots;
}

############################

our %megacycles;
$megacycles{1} = "160m";
$megacycles{3} = "80m";
$megacycles{5} = "60m";
$megacycles{7} = "40m";
$megacycles{10} = "30m";
$megacycles{14} = "20m";
$megacycles{18} = "17m";
$megacycles{21} = "15m";
$megacycles{24} = "12m";
$megacycles{26} = "11m";
$megacycles{27} = "11m";
$megacycles{28} = "10m";
$megacycles{29} = "10m";
$megacycles{40} = "8m";
$megacycles{41} = "8m";
$megacycles{42} = "8m";
$megacycles{43} = "8m";
$megacycles{44} = "8m";
$megacycles{50} = "6m";
$megacycles{51} = "6m";
$megacycles{52} = "6m";
$megacycles{53} = "6m";
$megacycles{69} = "4m";
$megacycles{70} = "4m";
$megacycles{144} = "2m";
$megacycles{145} = "2m";
$megacycles{146} = "2m";
$megacycles{147} = "2m";
$megacycles{220} = "1.25m";
$megacycles{221} = "1.25m";
$megacycles{222} = "1.25m";
$megacycles{223} = "1.25m";
$megacycles{224} = "1.25m";
$megacycles{432} = "0.70m";
$megacycles{902} = "0.33m";
$megacycles{1296} = "0.23m";

# when calling from eggdrop, parameters may be packed into first parameter.
if ($#ARGV == 0 && $ARGV[0] =~ m/ /) {
  @ARGV = split / /, $ARGV[0];
}

my ($phone, $cw, $digi, $band, $all) = (0, 0, 0, undef, 1);

my $i = 0;
while ($i <= $#ARGV) {
  if ($ARGV[$i] =~ /^--(ssb|phone)/i) {
    $phone = 1;
    $all = 0;
    $i++; next;
  }
  if ($ARGV[$i] =~ /^--cw/i) {
    $cw = 1;
    $all = 0;
    $i++; next;
  }
  if ($ARGV[$i] =~ /^--(digi|data)/i) {
    $digi = 1;
    $all = 0;
    $i++; next;
  }

  if ($ARGV[$i] =~ /^--([0-9]+c?m)/i) {
    $band = lc($1);
    $all = 0;
    $i++; next;
  }

  if ($ARGV[$i] =~ /^--/) {
    print "unknown option: $ARGV[$i]\n";
    print "usage: !potaspots [--phone|--cw|--digi] [--<band>] [number]\n";
    exit $exitnonzeroonerror;
  }

  if ($ARGV[$i] =~ /^\d+$/) {
    $limit = $ARGV[$i];
    $limit = 8 if $limit > 8 and $username eq getEggdropUID();
  } else {
    print "unexpected parameter: $ARGV[$i]\n";
    print "usage: !potaspots [--phone|--cw|--digi] [--<band>] [number]\n";
    exit $exitnonzeroonerror;
  }
  $i++;
}

my $url = "https://api.pota.app/spot/activator";
local $/;   # read entire file -- FIXME: potentially memory hungry
open (HTTP, '-|', "curl -L -4 -k --max-time 4 --retry 1 -s '$url'");
my $json = <HTTP>;
close(HTTP);

my $j = decode_json($json) or die "parse error: $json\n";

my $dtparser = DateTime::Format::Strptime->new(
  #see strftime
  pattern => '%Y-%m-%dT%H:%M:%S',
  time_zone => 'UTC',
  on_error => 'undef');

my @spots;

foreach my $s (@{$j}) {
  next if not $all and $cw and uc $s->{mode} ne "CW";
  next if not $all and $phone and not $s->{mode} =~ m/(SSB|USB|LSB|FM|AM)/i;
  next if not $all and $digi and not $s->{mode} =~ m/(RTTY|FT8|FT4|JT9|JT65|PSK|JS8)/i;
  next if not $all and defined $band and freq2band($s->{frequency} * 1000) ne $band;

  my $dt = $dtparser->parse_datetime($s->{spotTime});
  my $ts = $dt->epoch();
  my $cmt = $s->{comments};
  $cmt =~ s/RBN //;
  my $de = $s->{spotter};
  $de =~ s/-#//;
  my $desc = "$s->{reference} $s->{locationDesc} $s->{mode} $cmt";
  push (@spots, {ts => $ts,
		  src => "P",
		  de => $de,
		  dx => $s->{activator},
		  f => $s->{frequency},
		  msg => substr($desc, 0 , 28)}
	      );
}

my @sortedspots = sort { $b->{ts} <=> $a->{ts} } @spots;  # descending

show(\@sortedspots);

sub show
{
  my ($array) = @_;
  my $i = 0;
  if ((scalar @$array) == 0) {
    say "no spots found";
  }
  foreach my $spotref (@$array) {
    my %spot = %$spotref;
    printf "%-7s %-7s %5d %-28s %s %s\n", $spot{de}, $spot{dx}, $spot{f}, $spot{msg}, strftime("%H%Mz %d %b", gmtime($spot{ts})), $spot{src};
    if (++$i >= $limit) {
      last;
    }
  }
}

sub freq2band {
  my $freq = shift;
  my $band;
  our %megacycles;

  if ($freq > 1000000) {
    my $mc = int ($freq / 1000000);
    #print "MC: $freq $mc\n";
    $band = $megacycles{$mc};
  } else {
    my $kc = $freq / 1000;
    if (470 <= $kc and $kc <= 510) {
      $band = "630m";
    } elsif (130 <= $kc and $kc <= 140) {
      $band = "2200m";
    }
  }

  if (!defined $band) {
    #print "unknown band for frequency: $freq\n";
    return "";
  }
  return $band;
}
