#!/usr/bin/perl -w
#
# Search for upcoming hamfests near the user's location.
# Uses the ARRL hamfest search (https://www.arrl.org/hamfests/search)
# and the project's Location.pm for geocoding and distance.
#
# Searches by ARRL division (derived from user's state) and also by state,
# then merges and deduplicates results. Sorts by date (soonest first).
# Division-based search returns upcoming events months out.
#
# 2-clause BSD license.
# Copyright (c) 2026 cjh@github. All rights reserved.

use strict;
use utf8;
use feature 'unicode_strings';
binmode(STDOUT, ":utf8");

use URI::Escape;
use POSIX qw(strftime);

use File::Basename;
use Cwd 'realpath';
use lib dirname(realpath(__FILE__));
use Colors;
use Util;
use Location;

my $username = $ENV{'USER'} || $ENV{'USERNAME'} || getpwuid($<);

our $exitnonzeroonerror = 1;
$exitnonzeroonerror = 0 if $username eq getEggdropUID();

@ARGV = split(' ', join(' ', @ARGV));

my $useragent  = "Mozilla/5.0 (compatible; qrmbot)";
my $MAX_RESULTS  = 3;
my $DAYS_AHEAD   = 90;   # search window
my $MAX_DIST_MI  = 200;  # ignore hamfests farther than this

$MAX_RESULTS = 10 if $username ne getEggdropUID();

# --- Parse args: --geo lat,lon  and optional text location ---
my $geo_arg = undef;
my @text_args;
my $i = 0;
while ($i <= $#ARGV) {
  if ($ARGV[$i] eq "--geo" && $i + 1 <= $#ARGV) {
    $geo_arg = $ARGV[$i + 1];
    $i += 2;
  } else {
    push @text_args, $ARGV[$i];
    $i++;
  }
}
my $query = join(" ", @text_args);

# --- Resolve user lat/lon, state code, and display name ---
my ($user_lat, $user_lon, $state_code, $location_name);

if ($query && length($query) > 0) {
  # Forward geocode via Location.pm (handles grid squares, geo:lat,lon, or plain text QTH)
  my $coords = argToCoords($query);
  if (!defined $coords) {
    print "error: location not found: $query\n";
    exit $exitnonzeroonerror;
  }
  ($user_lat, $user_lon) = split(',', $coords);
  $location_name = geolocate($user_lat, $user_lon) // $query;

} elsif (defined $geo_arg && $geo_arg =~ /^(-?\d+\.?\d*),\s*(-?\d+\.?\d*)$/) {
  # Reverse geocode via Location.pm (Google Maps)
  ($user_lat, $user_lon) = ($1, $2);
  $location_name = geolocate($user_lat, $user_lon) // "your location";

} else {
  print "usage: !fest [location] -- set your QTH with !setgeo for automatic lookup\n";
  exit $exitnonzeroonerror;
}

# Extract two-letter US state code from geocoded location string (e.g. "Aurora, MO, USA")
if (defined $location_name && $location_name =~ /,\s*([A-Z]{2})\b/) {
  $state_code = $1;
}

# US state -> ARRL division ID mapping
my %state_to_division = (
  AL => 'SE', AK => 'NW', AZ => 'SW', AR => 'DL', CA => 'PC',
  CO => 'RM', CT => 'NE', DE => 'AT', DC => 'AT', FL => 'SE',
  GA => 'SE', HI => 'PC', ID => 'NW', IL => 'CL', IN => 'CL',
  IA => 'MW', KS => 'MW', KY => 'GL', LA => 'DL', ME => 'NE',
  MD => 'AT', MA => 'NE', MI => 'GL', MN => 'DK', MS => 'DL',
  MO => 'MW', MT => 'NW', NE => 'MW', NV => 'SW', NH => 'NE',
  NJ => 'AT', NM => 'RM', NY => 'HU', NC => 'RK', ND => 'DK',
  OH => 'GL', OK => 'WG', OR => 'NW', PA => 'AT', RI => 'NE',
  SC => 'SE', SD => 'DK', TN => 'DL', TX => 'WG', UT => 'RM',
  VT => 'NE', VA => 'RK', WA => 'NW', WV => 'RK', WI => 'CL',
  WY => 'RM',
);

# --- Search ARRL hamfest database by division + state, merge results ---
my $today    = strftime("%m/%d/%Y", localtime);
my @end_tm   = localtime(time + $DAYS_AHEAD * 86400);
my $end_date = sprintf("%02d/%02d/%04d", $end_tm[4]+1, $end_tm[3], $end_tm[5]+1900);

my $enc_start = uri_escape($today);
my $enc_end   = uri_escape($end_date);
my $date_params = "_method=POST"
  . "&data%5BDate%5D%5Bstart%5D=${enc_start}"
  . "&data%5BDate%5D%5Bend%5D=${enc_end}";

my $division = defined $state_code ? $state_to_division{$state_code} : undef;

# Fetch division results (broad regional coverage) and state results
# (catches any events the division search might miss), then deduplicate.
my $combined_html = "";
if (defined $division) {
  $combined_html .= fetchARRL(
    $date_params . "&data%5BLocation%5D%5Bdivision_id%5D=${division}");
}
if (defined $state_code) {
  $combined_html .= fetchARRL(
    $date_params . "&data%5BLocation%5D%5Bstate%5D=${state_code}");
}
if (!length($combined_html)) {
  print "error: could not reach ARRL hamfest search\n";
  exit $exitnonzeroonerror;
}

# --- Parse <li> results, deduplicate by ARRL event slug ---
my @events;
my %seen;
while ($combined_html =~ m|(<li>\s*<div class="img">.*?</li>)|gsi) {
  my $item = $1;
  my %ev;

  # Unique key: the ARRL hamfest URL slug
  if ($item =~ m|href="/hamfests/([^"]+)"\s+title="(?!Learn More)|) {
    my $slug = $1;
    next if $seen{$slug}++;
    $ev{slug} = $slug;
  } else {
    next;
  }

  # Lat/lon from Google Maps static map img
  if ($item =~ /markers=color:[^|]+\|(-?\d+\.?\d*),(-?\d+\.?\d*)/) {
    ($ev{lat}, $ev{lon}) = ($1, $2);
  } else {
    next;
  }

  # Event name (title attribute of the detail link)
  if ($item =~ m|href="/hamfests/[^"]*"\s+title="([^"]+)"|) {
    $ev{name} = decodeEntities($1);
  }
  next unless defined $ev{name};
  next if $ev{name} eq "Learn More";

  # Start date (in <span>)
  if ($item =~ m|<span>\s*(\d{1,2}/\d{1,2}/\d{4})|) {
    $ev{date} = $1;
  }
  next unless defined $ev{date};

  # City, State
  if ($item =~ m|<strong>Location:\s*</strong>\s*([^<]+)|) {
    ($ev{location} = $1) =~ s/\s+$//;
  }

  # Type (ARRL Hamfest / ARRL Convention / etc.)
  if ($item =~ m|<strong>Type:</strong>\s*([^<]+)|) {
    ($ev{type} = $1) =~ s/\s+$//;
  }

  # External website
  if ($item =~ m|<strong>Website:</strong>\s*<a href="([^"]+)"|) {
    $ev{website} = $1;
  }

  my ($dist_km, undef) = distBearing($user_lat, $user_lon, $ev{lat}, $ev{lon});
  $ev{dist_mi} = int($dist_km * 0.621371 + 0.5);

  push @events, \%ev;
}

if (@events == 0) {
  print "ðŸ“» No upcoming hamfests found in the ARRL database for the next $DAYS_AHEAD days\n";
  exit 0;
}

# Filter to within MAX_DIST_MI, sort soonest-first, cap at MAX_RESULTS
@events = grep { $_->{dist_mi} <= $MAX_DIST_MI } @events;
@events = sort {
  my ($am, $ad, $ay) = split('/', $a->{date});
  my ($bm, $bd, $by) = split('/', $b->{date});
  "$ay$am$ad" cmp "$by$bm$bd"
} @events;

if (@events == 0) {
  print "ðŸ“» No hamfests found within $MAX_DIST_MI miles in the next $DAYS_AHEAD days\n";
  exit 0;
}

my $count = @events < $MAX_RESULTS ? scalar @events : $MAX_RESULTS;

# --- Output ---
my @month_abbr = qw(Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec);
my $sep = " \x{00B7} ";

print "ðŸ“» Upcoming hamfests near " . bold($location_name) . ":\n";

for my $ev (@events[0..$count-1]) {
  my ($mon, $day, $yr) = split('/', $ev->{date});
  my $date_fmt = $month_abbr[$mon - 1] . " " . int($day);

  print "ðŸ“… " . bold($date_fmt) . " \x{2014} " . bold($ev->{name});
  print ", " . $ev->{location} if defined $ev->{location};
  print " (" . $ev->{dist_mi} . " mi)";
  print $sep . $ev->{type}    if defined $ev->{type};
  print $sep . $ev->{website} if defined $ev->{website};
  print "\n";
}

exit 0;

# ---- Helpers ----

sub fetchPOST {
  my ($url, $data) = @_;
  open(my $fh, '-|', "curl --max-time 15 -s -k -L -A \"$useragent\" "
    . "-X POST --data '$data' "
    . "-H 'Content-Type: application/x-www-form-urlencoded' "
    . "'$url'");
  binmode($fh, ":utf8");
  local $/;
  my $res = <$fh>;
  close($fh);
  return undef unless defined $res && length($res) > 0;
  return $res;
}

sub fetchGET {
  my $url = shift;
  open(my $fh, '-|', "curl --max-time 15 -s -k -L -A \"$useragent\" '$url'");
  binmode($fh, ":utf8");
  local $/;
  my $res = <$fh>;
  close($fh);
  return undef unless defined $res && length($res) > 0;
  return $res;
}

# Fetch page 1 via POST, then follow any "next" pagination links via GET.
sub fetchARRL {
  my ($post_data) = @_;
  my $combined = "";

  my $html = fetchPOST("https://www.arrl.org/hamfests/search", $post_data);
  return "" unless defined $html;
  $combined .= $html;

  while ($html =~ m|href="(/hamfests/search/page:\d+/[^"]+)"\s+class="next"|) {
    my $next_path = $1;
    $html = fetchGET("https://www.arrl.org$next_path");
    last unless defined $html;
    $combined .= $html;
  }

  return $combined;
}
