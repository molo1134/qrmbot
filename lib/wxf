#!/usr/bin/perl -w
# WUnderground API client -- forecast.  2-clause BSD license.

# Copyright 2018 /u/molo1134. All rights reserved.

# requires an API key from wunderground.com  Place into the file $HOME/.wunderground as follows:
#
# $apikey = "0123456789abcdef";

use strict;
use utf8;
use feature 'unicode_strings';
binmode(STDOUT, ":utf8");
use Encode qw(decode);
use I18N::Langinfo qw(langinfo CODESET);
use URI::Escape;
use Math::Round;
use POSIX qw(strftime);
use POSIX qw(tzset);
use Time::Piece ();

my $username = $ENV{'USER'} || $ENV{'USERNAME'} || getpwuid($<);

our $apikey = undef;
our $highlight = "vt100";
$highlight = "none" if ! -t STDOUT;
$highlight = "irc" if $username eq "eggdrop";

# change this to 0 to always exit with success
my $exitnonzeroonerror = 1;
$exitnonzeroonerror = 0 if $username eq 'eggdrop';

my $apikeyfile = $ENV{'HOME'} . "/.wunderground";
if (-e ($apikeyfile)) {
  require($apikeyfile);
} else {
  die "error: unable to read file $apikeyfile"
}
die "error: no API key set" unless defined($apikey);


my $i = 0;
my $loc;
my $short = 0;
while ($i <= $#ARGV) {
  if ($ARGV[$i] =~ /--short/) {
    $short = 1;
    $i++;
    next;
  }
  if (defined($loc)) {
    $loc = $loc . " " . $ARGV[$i];
  } else {
    $loc = $ARGV[$i];
  }
  $i++;
}

# decode command line from locale-specified codeset
my $codeset = langinfo(CODESET);
$loc = decode($codeset, $loc);

if (!defined($loc)) {
  print "usage: $0 <location>\n";
  exit $exitnonzeroonerror;
}

my $bold = "";
my $unbold = "";

if ($highlight eq "vt100") {
  $bold = "\e[1m";
  $unbold = "\e[0m";
} elsif ($highlight eq "irc" ) {
  $bold = "\002";
  $unbold = "\002";
}

$loc =~ s/^\s*//;
$loc =~ s/\s*$//;
$loc =~ s/\s/_/g;
my $encodedloc = uri_escape($loc);

my $url = "http://api.wunderground.com/api/$apikey/geolookup/q/$encodedloc.json";
my %geo;
my $in_location = 0;

open(HTTP, '-|', "curl -s -L --insecure '$url'");
binmode(HTTP, ":utf8");
while (<HTTP>) {
	#print;

  if (/"location":/) {
    $in_location = 1;
  }
  if (/"station":/) {
    $in_location = 0;
  }

  if (/"(\w+)":\s*(-?\d+|"[^"]*")/) {
    my $key = $1;
    my $val = $2;
    $val =~ s/^"(.*)"$/$1/;

    if ($in_location == 1) {
	    #print "$key = $val\n";
      $geo{$key} = $val;
    }
  }
}
close(HTTP);

my $place = "$geo{'city'}, ";
$place .= "$geo{'state'}, " unless $geo{'state'} eq "";
$place .= $geo{'country_name'};

my $lat = nearest(.1, $geo{'lat'});
my $lon = nearest(.1, $geo{'lon'});


my @alerts;

$url = "http://api.wunderground.com/api/$apikey/alerts/q/$encodedloc.json";
open(HTTP, '-|', "curl -s -L --insecure '$url'");
binmode(HTTP, ":utf8");
my $inalerts = 0;
my $description = undef;
my $end = 0;
my $zone = undef;
my $europe = 0;

while (<HTTP>) {
  chomp;

  if (/"alerts": \[/) {
    $inalerts = 1;
  }

  if (/"(\w+)":\s*(-?\d+|"[^"]*")/) {
    my $key = $1;
    my $val = $2;
    $val =~ s/^"(.*)"$/$1/;
    #print "$key = $val\n";

    if (/meteoalarm/) {
      $europe = 1;
    }

    if ($inalerts == 1 && $key eq "description" && $europe == 0) {
      $description = $val;
    }
    if ($inalerts == 1 && $key eq "expires_epoch" && $europe == 0) {
      $end = $val;
    }
    if ($inalerts == 1 && $key eq "tz_long" && $europe == 0) {
      $zone = $val;
    }

    if ($inalerts == 1 && $europe == 1 && $key eq "wtype_meteoalarm_name") {
      $description = $val;
    }
    if ($inalerts == 1 && $europe == 1 && $key eq "level_meteoalarm_name") {
      $description = "$description ($val)";
    }
    if ($inalerts == 1 && $europe == 1 && $key eq "expires") {
      $end = Time::Piece->strptime($val, "%Y-%m-%d %H:%M:%S %Z")->epoch;
      $zone = $geo{tz_long}; # from geo query
    }
  }

  if (defined($description) && /}$/) {
    $zone = "UTC" if !defined($zone);
    $ENV{'TZ'} = $zone;
    tzset;
    $end = strftime("%a %H:%M %Z", localtime($end)); # e.g. Sun 11:00 PDT

    push(@alerts, "${bold}Alert${unbold}: ${bold}${description}${unbold} until ${end}");

    $description = $zone = undef;
    $end = 0;
  }
}
close HTTP;

$url = "http://api.wunderground.com/api/$apikey/forecast/q/$encodedloc.json";

my $period;
my $in_forecast;
my $error = 0;
my %rec;

#print "$url\n";
open(HTTP, '-|', "curl -s -L --insecure '$url'");
binmode(HTTP, ":utf8");
while (<HTTP>) {
  chomp;
  #print;
  if (/"results"/) {
    print "location must be more specific: $loc\n";
    exit $exitnonzeroonerror;
  }

  if (/"error"/) {
    $error = 1;
  }
  if ($error == 1 && /"description"/) {
    /"(\w+)":\s*"([^"]*)"/;
    print "error: $2\n";
    exit $exitnonzeroonerror;
  }

  if (/"txt_forecast"/) {
    $in_forecast = 1;
  }

  if (/simpleforecast/) {
    $in_forecast = 0;
  }

  if (/"(\w+)":\s*(-?\d+|"[^"]*")/) {
    my $key = $1;
    my $val = $2;
    $val =~ s/^"(.*)"$/$1/;

    if ($key eq "period") {
      $period = $val;
    }

    if ($in_forecast) {
      $key = "${period}_${key}" if defined($period);
      #print "$key = $val\n";
      $rec{"$key"} = $val unless $val eq "NA" or $val eq "--";
    }

  }

}
close(HTTP);


# unicode weather chars
#       sun: â˜€ â˜¼ ğŸŒ
#     cloud: â˜
#    partly: â›…
#  umbrella: â˜‚
#   snowman: â˜ƒ â›„ â›‡
#      rain: â˜” â›†
#      moon: â˜¾ â˜½ ğŸŒ‘ ğŸŒ’ ğŸŒ“ ğŸŒ” ğŸŒ• ğŸŒ– ğŸŒ— ğŸŒ˜ ğŸŒ™ ğŸŒš ğŸŒ› ğŸŒœ ğŸŒ
# lightning: âš¡ â›ˆ â˜‡ â˜ˆ
#   cyclone: ğŸŒ€
#       fog: ğŸŒ â–’
#

my $units = "_metric";
$units = "" if $geo{'country_iso3166'} eq "US";

print "Forecast for $bold$place$unbold ($lon,$lat) as of $rec{'date'}:\n";

foreach my $alert (@alerts) {
  print " $alert\n";
}

$i = 0;
my $max = 20;
$max = 3 if $short == 1;
while ($i < $max and defined $rec{${i}."_title"}) {
  if ($units eq "_metric" and $rec{"${i}_fcttext${units}"} eq "") {
    print "${bold}warning${unbold}: metric forecast unavailable\n";
    $units = "";
  }
  my $forecast = $rec{${i}."_fcttext".$units};
  $forecast = "no result found" if $forecast eq "";
  my $title = $rec{"${i}_title"} || $i;
  print " $bold$title$unbold: $forecast\n";
  $i++;
}

exit 0;
